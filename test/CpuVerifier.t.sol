// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.23;

import "forge-std/Test.sol";
import "forge-std/StdJson.sol";
import "../src/layout_starknet/CpuVerifier.sol";
import "../src/common/MemoryPageFactRegistry.sol";
import "../src/layout_starknet/CpuOods.sol";
import "../src/layout_starknet/CpuConstraintPoly.sol";
import "../src/common/PrimeFieldElement0.sol";
import "evm-verifier-columns/PedersenHashPointsXColumn.sol";
import "evm-verifier-columns/PedersenHashPointsYColumn.sol";
import "evm-verifier-columns/EcdsaPointsXColumn.sol";
import "evm-verifier-columns/EcdsaPointsYColumn.sol";
import "evm-verifier-columns/PoseidonPoseidonFullRoundKey0Column.sol";
import "evm-verifier-columns/PoseidonPoseidonFullRoundKey1Column.sol";
import "evm-verifier-columns/PoseidonPoseidonFullRoundKey2Column.sol";
import "evm-verifier-columns/PoseidonPoseidonPartialRoundKey0Column.sol";
import "evm-verifier-columns/PoseidonPoseidonPartialRoundKey1Column.sol";

contract CpuVerifierTest is Test {
    using stdJson for string;
    
    CpuVerifier public verifier;
    MemoryPageFactRegistry public factRegistry;
    CpuOods public oodsContract;
    CpuConstraintPoly public constraintPoly;
    
    address[] public auxPolynomials;
    
    // Periodic column contract addresses - must be set before deployment
    // These are typically generated by stark-evm-adapter
    address[9] public periodicColumns;
    
    // K_MODULUS constant
    uint256 internal constant K_MODULUS = 0x800000000000011000000000000000000000000000000000000000000000001;
    
    function setUp() public {
        // Deploy MemoryPageFactRegistry
        factRegistry = new MemoryPageFactRegistry();
        
        // Deploy CpuOods - no constructor parameters needed
        oodsContract = new CpuOods();
        
        // Deploy CpuConstraintPoly - no constructor parameters needed
        constraintPoly = new CpuConstraintPoly();
        
        // Deploy periodic column contracts from evm-verifier
        // These are the actual generated contracts with real periodic column data
        periodicColumns = [
            address(new PedersenHashPointsXColumn()),
            address(new PedersenHashPointsYColumn()),
            address(new EcdsaPointsXColumn()),
            address(new EcdsaPointsYColumn()),
            address(new PoseidonPoseidonFullRoundKey0Column()),
            address(new PoseidonPoseidonFullRoundKey1Column()),
            address(new PoseidonPoseidonFullRoundKey2Column()),
            address(new PoseidonPoseidonPartialRoundKey0Column()),
            address(new PoseidonPoseidonPartialRoundKey1Column())
        ];
        
        // Set up aux polynomials array
        auxPolynomials = new address[](10);
        auxPolynomials[0] = address(constraintPoly);
        auxPolynomials[1] = periodicColumns[0];
        auxPolynomials[2] = periodicColumns[1];
        auxPolynomials[3] = periodicColumns[2];
        auxPolynomials[4] = periodicColumns[3];
        auxPolynomials[5] = periodicColumns[4];
        auxPolynomials[6] = periodicColumns[5];
        auxPolynomials[7] = periodicColumns[6];
        auxPolynomials[8] = periodicColumns[7];
        auxPolynomials[9] = periodicColumns[8];
        
        // Deploy CpuVerifier
        verifier = new CpuVerifier(
            auxPolynomials,
            address(oodsContract),
            address(factRegistry),
            80,  // numSecurityBits
            20   // minProofOfWorkBits
        );
    }
    
    /**
     * @notice Converts a hex string to uint256
     * @param hexString The hex string (with or without 0x prefix)
     * @return The uint256 value
     */
    function hexStringToUint256(string memory hexString) internal pure returns (uint256) {
        bytes memory hexBytes = bytes(hexString);
        require(hexBytes.length > 0, "Empty hex string");
        
        uint256 start = 0;
        if (hexBytes.length >= 2 && hexBytes[0] == '0' && hexBytes[1] == 'x') {
            start = 2;
        }
        
        uint256 result = 0;
        for (uint256 i = start; i < hexBytes.length; i++) {
            uint8 char = uint8(hexBytes[i]);
            uint8 digit;
            
            if (char >= 48 && char <= 57) {
                digit = char - 48; // '0'-'9'
            } else if (char >= 65 && char <= 70) {
                digit = char - 55; // 'A'-'F'
            } else if (char >= 97 && char <= 102) {
                digit = char - 87; // 'a'-'f'
            } else {
                revert("Invalid hex character");
            }
            
            result = result * 16 + digit;
        }
        
        return result;
    }
    
    /**
     * @notice Converts an array of hex strings to uint256 array
     * @param hexStrings The array of hex strings
     * @return The array of uint256 values
     */
    function hexStringArrayToUint256Array(string[] memory hexStrings) internal pure returns (uint256[] memory) {
        uint256[] memory result = new uint256[](hexStrings.length);
        for (uint256 i = 0; i < hexStrings.length; i++) {
            result[i] = hexStringToUint256(hexStrings[i]);
        }
        return result;
    }
    
    /**
     * @notice Registers memory page facts using provided z and alpha values
     * @param inputJson The prepared input JSON string (for memory pairs data)
     * @param z The first interaction element
     * @param alpha The second interaction element
     */
    function registerMemoryPageFactsWithZAlpha(string memory inputJson, uint256 z, uint256 alpha) internal {
        // Log the z and alpha values being used for fact registration
        console.log("Registering facts with z:");
        console.logBytes32(bytes32(z));
        console.log("Registering facts with alpha:");
        console.logBytes32(bytes32(alpha));
        
        // Parse regular page (page 0) - MUST exist for Cairo programs
        string memory regularPageKey = ".memory_page_facts.regular_page";
        string[] memory memoryPairsHex = vm.parseJsonStringArray(inputJson, string.concat(regularPageKey, ".memory_pairs"));
        require(memoryPairsHex.length > 0, "Regular page (page 0) must exist and have memory pairs");
        uint256[] memory memoryPairs = hexStringArrayToUint256Array(memoryPairsHex);
        factRegistry.registerRegularMemoryPage(memoryPairs, z, alpha, K_MODULUS);
        
        // Parse continuous pages (page > 0)
        // Iterate through continuous pages until we hit an error (means no more pages)
        string memory continuousPagesKey = ".memory_page_facts.continuous_pages";
        uint256 i = 0;
        while (true) {
            string memory pageKey = string.concat(continuousPagesKey, "[", vm.toString(i), "]");
            try vm.parseJsonString(inputJson, string.concat(pageKey, ".start_addr")) returns (string memory startAddrHex) {
                string[] memory valuesHex = vm.parseJsonStringArray(inputJson, string.concat(pageKey, ".values"));
                
                uint256 startAddr = hexStringToUint256(startAddrHex);
                uint256[] memory values = hexStringArrayToUint256Array(valuesHex);
                
                factRegistry.registerContinuousMemoryPage(startAddr, values, z, alpha, K_MODULUS);
                i++;
            } catch {
                // No more continuous pages
                break;
            }
        }
    }
    
    function test_VerifyProof() public {
        // Load input.json (prepared by prepare-input binary)
        string memory inputJson = vm.readFile("./input.json");
        require(bytes(inputJson).length > 0, "input.json is empty or not found");

        // Parse proofParams, proof, publicInput from input.json
        string[] memory proofParamsHex = vm.parseJsonStringArray(inputJson, ".proof_params");
        string[] memory proofHex = vm.parseJsonStringArray(inputJson, ".proof");
        string[] memory publicInputHex = vm.parseJsonStringArray(inputJson, ".public_input");

        // Convert hex strings to uint256 arrays
        uint256[] memory proofParams = hexStringArrayToUint256Array(proofParamsHex);
        uint256[] memory proof = hexStringArrayToUint256Array(proofHex);
        uint256[] memory publicInput = hexStringArrayToUint256Array(publicInputHex);

        // Compute z and alpha using the verifier's PRNG (to match exactly what verifier will use)
        (uint256 z, uint256 alpha) = verifier.computeInteractionElements(proofParams, proof, publicInput);

        console.log("Verifier computed z:");
        console.logBytes32(bytes32(z));
        console.log("Verifier computed alpha:");
        console.logBytes32(bytes32(alpha));

        // Register memory page facts using the verifier's z and alpha
        registerMemoryPageFactsWithZAlpha(inputJson, z, alpha);

        // Verify proof
        verifier.verifyProofExternal(proofParams, proof, publicInput);
    }
}
